<!DOCTYPE html>
<html lang="da">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Blinkkode‑læser (ingen app)</title>
  <style>
    :root { --bg:#0b0f14; --fg:#e8eef6; --muted:#93a3b3; --acc:#5dd4a3; --warn:#ffb703; --err:#ef476f; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial}
    .wrap{display:flex;flex-direction:column;min-height:100%}
    header{padding:12px 16px;border-bottom:1px solid #1a2430;display:flex;align-items:center;justify-content:space-between;gap:12px}
    header h1{font-size:18px;margin:0;font-weight:600}
    main{flex:1;display:flex;flex-direction:column;gap:12px;padding:12px}
    .videoBox{position:relative;border-radius:16px;overflow:hidden;background:#0e1520;border:1px solid #1a2430}
    video{width:100%;height:auto;display:block;background:black}
    canvas{display:none}
    .overlay{position:absolute;inset:0;pointer-events:none}
    .uiRow{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    button,select,input{background:#122030;border:1px solid #213245;color:var(--fg);border-radius:10px;padding:10px 12px;font-size:14px}
    button.primary{background:var(--acc);color:#041312;border:0;font-weight:600}
    button.warn{background:var(--warn);color:#221a00;border:0;font-weight:600}
    .pill{padding:6px 10px;border-radius:999px;background:#0e1a28;border:1px solid #203044;color:var(--muted);font-size:12px}
    .panel{border:1px solid #1a2430;border-radius:14px;padding:12px;background:#0f1622}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:760px){.grid{grid-template-columns:1fr 1fr}}
    .stat{display:flex;justify-content:space-between;color:var(--muted);font-size:14px}
    .stat strong{color:var(--fg)}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#0e1a28;border:1px solid #203044;margin-left:6px;font-size:12px;color:var(--muted)}
    .status{font-family:ui-monospace,Menlo,Consolas,monospace;background:#0c131d;border:1px solid #1a2430;border-radius:12px;padding:10px;white-space:pre-wrap;min-height:48px}
    .footer{color:#8ea0b3;font-size:12px}
    a{color:#a8e5ff}
    .pass{color:#5dd4a3}
    .fail{color:#ef476f}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Blinkkode‑læser <span class="badge">Ingen app – kun browser</span></h1>
    <div class="pill">1) Åbn kamera · 2) Tryk på LED · 3) Læs fejlen</div>
  </header>
  <main>
    <div class="videoBox" id="videoBox">
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>
      <svg class="overlay" id="overlay"></svg>
    </div>

    <div class="uiRow">
      <button id="btnStart" class="primary">Åbn kamera</button>
      <button id="btnStop" title="Stop kamera">Stop</button>
      <button id="btnCal" class="warn" title="Kør kort auto‑kalibrering">Kalibrér</button>
      <select id="mode">
        <option value="count">Tælle‑blinks (klassisk: N blink → pause)</option>
      </select>
      <label class="pill">Pausegrænse <input id="pauseMs" type="number" value="900" style="width:80px;margin-left:6px"> ms</label>
      <label class="pill">ROI størrelse <input id="roiSize" type="number" value="64" style="width:60px;margin-left:6px"> px</label>
    </div>

    <div class="grid">
      <div class="panel">
        <div class="stat"><span>Status</span><strong id="statState">Idle</strong></div>
        <div class="stat"><span>Blinks i aktuel cyklus</span><strong id="statBlinks">0</strong></div>
        <div class="stat"><span>Sidste kode</span><strong id="statLast">-</strong></div>
        <div class="stat"><span>Signal‑tilstand</span><strong id="statLevel">-</strong></div>
      </div>
      <div class="panel">
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <input id="manualCount" type="number" placeholder="Skriv antal blinks…" />
          <button id="btnManual">Slå op manuelt</button>
        </div>
        <div id="lookup" class="status" style="margin-top:8px">Klar.</div>
      </div>
    </div>

    <div class="panel">
      <strong>Instruktion</strong>
      <ol>
        <li>Tryk <em>Åbn kamera</em> og giv tilladelse.</li>
        <li>Ret kameraet mod den blinkende LED og <strong>tryk på LED'en</strong> på skærmen for at låse målefelt (ROI).</li>
        <li>Vent én gentagelse (LED blinker N gange og holder en kort pause). Koden vises automatisk.</li>
      </ol>
      <div class="footer">Tip: Sid rimeligt tæt på LED'en. Undgå at LED'en fylder hele billedet. Hvis lysforhold ændrer sig, tryk <em>Kalibrér</em>.</div>
    </div>

    <div class="panel">
      <strong>Fejlkode‑opslag (redigér nedenfor)</strong>
      <pre id="codeExplain" class="status">Indlæs en kode…</pre>
    </div>

    <div class="panel">
      <strong>Tests</strong>
      <div id="tests" class="status">Kører tests…</div>
      <div class="footer">Tests verificerer blink‑parseren og opslagstabellen. De kræver ikke kamera.</div>
    </div>

    <div class="panel footer">
      Siden kører lokalt i browseren og uploader intet. Læg den på jeres eget domæne og sæt et QR‑klistermærke ved LED'en.
    </div>
  </main>
</div>

<script>
// === KONFIGURATION: Tilpas fejlkode‑tabellen her ===
// Kortlægning: { antal_blinks: {title: "…", fix: "…", details: "…"} }
const ERROR_MAP = {
  1: { title: "Overtemperatur", fix: "Kontrollér luftflow/filtre.", details: "Temperatur over grænse. Lad enheden køle ned, rens filter, tjek ventilator." },
  2: { title: "Lav netspænding", fix: "Mål forsyning og klemmer.", details: "Netspænding under minimum i mere end X sekunder." },
  3: { title: "Overstrøm", fix: "Se efter kortslutning/last.", details: "Strømgrænse nået gentagne gange." },
  4: { title: "Sensorfejl", fix: "Tjek stik/sensorledning.", details: "Defekt eller frakoblet føler." },
  5: { title: "Kommunikationsfejl", fix: "Genstart og tjek bus/ledning.", details: "Ingen/korrupt kommunikation." }
  // Tilføj jeres reelle koder her…
};

// === STATE ===
const els = {
  video: document.getElementById('video'),
  canvas: document.getElementById('canvas'),
  overlay: document.getElementById('overlay'),
  btnStart: document.getElementById('btnStart'),
  btnStop: document.getElementById('btnStop'),
  btnCal: document.getElementById('btnCal'),
  statState: document.getElementById('statState'),
  statBlinks: document.getElementById('statBlinks'),
  statLast: document.getElementById('statLast'),
  statLevel: document.getElementById('statLevel'),
  mode: document.getElementById('mode'),
  pauseMs: document.getElementById('pauseMs'),
  roiSize: document.getElementById('roiSize'),
  manualCount: document.getElementById('manualCount'),
  btnManual: document.getElementById('btnManual'),
  lookup: document.getElementById('lookup'),
  codeExplain: document.getElementById('codeExplain'),
  videoBox: document.getElementById('videoBox'),
  tests: document.getElementById('tests')
};

let stream=null, running=false, rafId=null;
let roi = null; // {x,y,size} i videopixels
let lastTS=0, isOn=false, onCount=0, lastBlinkTs=0, lastCycle=0;
let mu=0, s2=0, n=0; // online mean/variance for adaptiv tærskel
let calibrating=false;

function fmt(x){return Math.round(x*10)/10}
function setState(s){ els.statState.textContent=s }

async function startCam(){
  try{
    // --- Preflight checks for common platform blocks ---
    if(!('mediaDevices' in navigator) || !('getUserMedia' in navigator.mediaDevices)){
      throw new Error('Browser understøtter ikke kamera‑API (getUserMedia). Prøv Safari/Chrome/Edge.')
    }
    if(!isSecureContext){
      throw new Error('Siden kører ikke i en sikker kontekst. Brug HTTPS eller http://localhost (ikke file:// eller http://).')
    }
    if(window.top !== window.self){
      // Sandsynligvis indlejret (fx preview/sandbox) hvor kamera typisk er blokeret
      throw new Error('Siden er indlejret i en sandbox/iframe uden kamera‑tilladelse. Åbn den som selvstændig side på eget domæne.')
    }

    // VIGTIGT: constraints er ét objekt – audio:false skal være inden i det
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
    els.video.srcObject = stream;
    await els.video.play();
    running=true; setState('Kører');
    setupOverlay();
    loop();
  }catch(e){
    // Brug én linje (ingen rå newlines i streng‑literal) for at undgå parserfejl i visse previews
    setState('Kamera‑fejl: ' + e.message + ' — Tjek: HTTPS, ikke‑iframe, giv tilladelse, og nulstil evt. blokeret kameratilladelse i browserens website‑indstillinger.');
  }
}

function stopCam(){
  running=false; cancelAnimationFrame(rafId);
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null }
  setState('Stoppet');
}

function setupOverlay(){
  const update = ()=>{
    const vw = els.video.videoWidth||0, vh = els.video.videoHeight||0;
    els.canvas.width = vw; els.canvas.height = vh;
  };
  if(els.video.readyState>=2) update();
  els.video.addEventListener('loadedmetadata', update, {once:true});
}

function drawRoi(){
  const svg = els.overlay; svg.innerHTML='';
  if(!roi) return;
  // Transform ROI (video coords) til skærm coords
  const rect = els.video.getBoundingClientRect();
  const vw = els.video.videoWidth, vh = els.video.videoHeight;
  const arVideo = vw/vh, arBox = rect.width/rect.height;
  let sx, sy, ox, oy; // scale & offset fra video→skærm
  if(arVideo>arBox){
    sx = rect.width / vw; sy = sx;
    ox = 0; oy = (rect.height - vh*sy)/2;
  } else {
    sy = rect.height / vh; sx = sy;
    oy = 0; ox = (rect.width - vw*sx)/2;
  }
  const x = roi.x*sx + ox, y = roi.y*sy + oy, s = roi.size*sx;
  const ns = svg.namespaceURI;
  const r = document.createElementNS(ns,'rect');
  r.setAttribute('x', x- s/2); r.setAttribute('y', y- s/2);
  r.setAttribute('width', s); r.setAttribute('height', s);
  r.setAttribute('rx', 8); r.setAttribute('ry', 8);
  r.setAttribute('fill', 'none'); r.setAttribute('stroke', '#5dd4a3'); r.setAttribute('stroke-width', '2');
  svg.appendChild(r);
}

function pickRoi(ev){
  if(!els.video.videoWidth) return;
  const rect = els.video.getBoundingClientRect();
  const vw = els.video.videoWidth, vh = els.video.videoHeight;
  const arVideo = vw/vh, arBox = rect.width/rect.height;
  let sx, sy, ox, oy;
  if(arVideo>arBox){ sx = vw/rect.width; sy = sx; ox = 0; oy = (rect.height - rect.width/arVideo)/2 }
  else { sy = vh/rect.height; sx = sy; oy = 0; ox = (rect.width - rect.height*arVideo)/2 }
  const x = (ev.clientX - rect.left - ox) * sx;
  const y = (ev.clientY - rect.top - oy) * sy;
  const size = Math.max(8, Math.min(vw, vh, parseInt(els.roiSize.value)||64));
  roi = {x, y, size};
  mu=0; s2=0; n=0; // reset læring
  drawRoi();
}

function sampleROI(ctx){
  const s = roi.size|0; const x = Math.max(0, Math.min(els.canvas.width-s, (roi.x - s/2)|0));
  const y = Math.max(0, Math.min(els.canvas.height-s, (roi.y - s/2)|0));
  const img = ctx.getImageData(x,y,s,s).data; // RGBA
  let sum=0;
  for(let i=0;i<img.length;i+=4){ // luma approx
    sum += (img[i]*0.2126 + img[i+1]*0.7152 + img[i+2]*0.0722);
  }
  return sum/(img.length/4)/255; // 0..1
}

function loop(){
  if(!running) return;
  rafId = requestAnimationFrame(loop);
  const v = els.video; if(!v.videoWidth) return;
  const ctx = els.canvas.getContext('2d', {willReadFrequently:true});
  ctx.drawImage(v, 0,0, els.canvas.width, els.canvas.height);
  if(!roi){ els.statLevel.textContent='Vælg LED (tryk på video)'; return; }

  const val = sampleROI(ctx);
  // adaptiv baggrund & hysterese
  n++; const delta = val - mu; mu += delta/n; s2 += delta*(val - mu);
  const sigma = Math.sqrt(s2/Math.max(1,n-1));
  const thHi = mu + 3*sigma;
  const thLo = mu + 1*sigma;
  let nowOn = isOn; // start med tidligere tilstand
  if(val>thHi) nowOn = true; else if(val<thLo) nowOn = false;

  // kalibreringsfase: ignorér tælling i de første 500 ms efter tryk på Kalibrér
  const now = performance.now();
  if(calibrating && now - lastTS < 500){
    els.statLevel.textContent = `Kalibrerer… μ=${fmt(mu)} σ=${fmt(sigma)}`;
    lastTS = now; return;
  } else { calibrating=false; }

  // kantdetektion (OFF→ON)
  if(!isOn && nowOn){
    onCount++;
    lastBlinkTs = now;
    els.statBlinks.textContent = onCount;
  }
  isOn = nowOn;

  // afslut cyklus ved lang pause (split ved >=)
  const pauseMs = parseInt(els.pauseMs.value)||900;
  if(onCount>0 && (now - lastBlinkTs) >= pauseMs){
    lastCycle = onCount;
    els.statLast.textContent = String(lastCycle);
    showLookup(lastCycle);
    onCount = 0;
    els.statBlinks.textContent = '0';
  }

  els.statLevel.textContent = `${nowOn? 'ON':'off'} · v=${fmt(val)} μ=${fmt(mu)} σ=${fmt(sigma)} thHi=${fmt(thHi)}`;
  lastTS = now;
}

function showLookup(code){
  const e = ERROR_MAP[code];
  if(e){
    els.lookup.textContent = `${code} blink${code===1?'':'s'} → ${e.title}\nLøsning: ${e.fix}\nDetaljer: ${e.details}`;
    els.codeExplain.textContent = `${code}: ${e.title}\n${e.fix}\n${e.details}`;
  } else {
    els.lookup.textContent = `${code} blinks → Ukendt kode. (Tilføj i ERROR_MAP i koden)`;
    els.codeExplain.textContent = `Ukendt kode: ${code}. Opdatér ERROR_MAP i kilden.`;
  }
}

// --- UI hooks ---
(function(){
  const tips=[];
  if(window.top !== window.self) tips.push('Du ser siden i en indlejret visning (sandbox). Kamera er ofte blokeret.');
  if(!isSecureContext) tips.push('Brug HTTPS eller http://localhost – ikke file:// eller http://.');
  if(tips.length){ els.statState.textContent = 'Forudsætninger: '+tips.join(' ') }
})();

els.btnStart.addEventListener('click', startCam);
els.btnStop.addEventListener('click', stopCam);
els.btnCal.addEventListener('click', ()=>{ calibrating=true; mu=0; s2=0; n=0; });
['click','touchend'].forEach(evt=>{
  els.video.addEventListener(evt, (ev)=>{
    const p = ev.changedTouches? ev.changedTouches[0] : ev;
    pickRoi(p);
  });
});
els.btnManual.addEventListener('click', ()=>{
  const nn = parseInt(els.manualCount.value||'');
  if(!isNaN(nn)) showLookup(nn);
});

// === TESTS (ingen kamera krævet) ===
function decodeCyclesFromOnEdges(tsArray, pause){
  // tsArray: stigende ON‑kant tidsstempler (ms). Returnér liste af blink‑antal pr. cyklus.
  const out=[]; let c=0; let prev=undefined;
  for(const t of tsArray){
    if(prev!==undefined && (t - prev) >= pause){ if(c>0) out.push(c); c=0; }
    c++; prev=t;
  }
  if(c>0) out.push(c);
  return out;
}

function runTests(){
  const results=[]; const pause=900;
  const tests = [
    {name:'1) Enkelt cyklus, 3 blinks', inp:[100,300,500], exp:[3]},
    {name:'2) To cyklusser 2 + 5', inp:[0,200, 2000,2200,2400,2600,2800], exp:[2,5]},
    {name:'3) Grænsetilfælde præcis ved pause (skal splitte)', inp:[0,200, 1100,1300], exp:[2,2]},
    {name:'4) Hurtige blinks (ingen split)', inp:[0,150,260,370,480], exp:[5]},
    {name:'5) Tom input', inp:[], exp:[]},
    {name:'6) Opslag eksisterende kode (3)', inp:[0,100,200], exp:[3], mapCheck:3},
    {name:'7) Opslag ukendt kode (7)', inp:[0,100,200,300,400,500,600], exp:[7], mapCheck:7},
    {name:'8) Single blink', inp:[500], exp:[1]},
    {name:'9) Stor pause før første (ingen effekt)', inp:[2000,2100], exp:[2]},
    {name:'10) Tre cyklusser 1+1+1 m. lange pauser', inp:[0, 2000, 4000], exp:[1,1,1]}
  ];

  for(const t of tests){
    const got = decodeCyclesFromOnEdges(t.inp, pause);
    const ok = JSON.stringify(got)===JSON.stringify(t.exp);
    if(!ok){ results.push(`❌ ${t.name}: exp ${JSON.stringify(t.exp)} got ${JSON.stringify(got)}`); continue; }
    if(t.mapCheck!==undefined){
      const has = !!ERROR_MAP[t.mapCheck];
      if(t.mapCheck===3 && !has) results.push(`❌ Opslag: forventede kode 3 i ERROR_MAP`);
      else if(t.mapCheck===7 && has) results.push(`❌ Opslag: kode 7 burde være ukendt i ERROR_MAP`);
      else results.push(`✅ ${t.name}`);
    } else {
      results.push(`✅ ${t.name}`);
    }
  }
  els.tests.innerHTML = results.map(r => r.includes('✅')? `<span class="pass">${r}</span>` : `<span class="fail">${r}</span>`).join('\n');
}

runTests();
// iOS kræver bruger‑gesture → ingen auto‑start af kamera
</script>
</body>
</html>
